[
["index.html", "Kursmaterial till Certifierad Data Scientist Kapitel 1 Om dokumentet", " Kursmaterial till Certifierad Data Scientist Ferrologic 2019-10-14 Kapitel 1 Om dokumentet För att ta del av det här materialet behöver du inte några särskilda förkunskaper. Övningarna och upplägget följer boken R for Data Science av Hadley Wickham och Garrett Grolemund som finns gratis. Den boken är ett utmärkt fördjupande komplement till det här materialet. "],
["intro.html", "Kapitel 2 Introduktion till R 2.1 Saknade värden (missing values) 2.2 R är ett funktionellt programmeringsspråk 2.3 Data frames 2.4 Paket 2.5 tidyverse and friends 2.6 Workflow i R 2.7 Att skriva kod i R 2.8 Rmarkdown", " Kapitel 2 Introduktion till R R är ett programmeringsspråk för dataanalys. Men R sträcker sig långt utöver enkla databearbetningar och statistisk modellering. Tack vare ett aktivt community har det utvecklats en stor mängd paket för att lösa många av de olika uppgifter en dataanalytiker kan tänkas ställas inför. R kan i sin enklaste form användas som en miniräknare med +, -, / eller *. Exempelvis: 100 + 4 ## [1] 104 Eller: 4 * 6 - 2 ## [1] 22 Beräkningar, eller alla former av manipuleringar kan sparas i så kallade objekt. Exempelvis kan vi spara en av ovanstående beräkningar i objektet x med &lt;- som kallas för the assign operator. x &lt;- 100 + 4 x ## [1] 104 Pilen &lt;- kan även vändas på -&gt; 100 + 4 -&gt; x x ## [1] 104 Du kan spara flera värden i ett objekt genom att omsluta dem med funktionen c() och separatera med , (c står för combine). Då kallas objektet för en vector. x &lt;- c(4, 100 + 4, 10 * 2) x ## [1] 4 104 20 Objekt och vektorer är inte begränsade till numeriska värden utan kan även innehålla text. text &lt;- c(&quot;hej&quot;, &quot;jag&quot;, &quot;älskar&quot;, &quot;r&quot;) text ## [1] &quot;hej&quot; &quot;jag&quot; &quot;älskar&quot; &quot;r&quot; Vi kan dock inte blanda text och numeriska värden. Då kommer R att tolka det som text. blandat &lt;- c(1, 5, &quot;hej&quot;, 6) blandat ## [1] &quot;1&quot; &quot;5&quot; &quot;hej&quot; &quot;6&quot; 2.1 Saknade värden (missing values) Ett vanligt fenomen i data från verkligheten är saknade värden. Saknade värden representeras i R med NA. NA är inte noll. Det är inte heller ett värde. Det är helt enkelt en indikation på att vi inte vet vilket värde som ligger där. Det här upplevde i alla fall jag som lite förvirrande till en början. Om vi har en vektor med NA: x &lt;- c(4, NA, 2, 50) Och kollar vilka värden som är större än 2. x &gt; 2 ## [1] TRUE NA FALSE TRUE Så ser vi att vår observation med NA inte är TRUE eller FALSE utan helt enkelt NA. Om vi vill kolla vilka värden som är NA borde vi kunna göra samma sak: x == NA ## [1] NA NA NA NA Det här svaret känns kanske inte intuitivt men det här beror på att vi helt enkelt inte vet. Det går inte att utvärdera om x är NA. Vi kan illustrera med ett exempel: filips_ålder &lt;- NA helenas_ålder &lt;- NA filips_ålder == helenas_ålder ## [1] NA Är Filips ålder densamma som Helenas ålder för att vi saknar värdet? Nej, det går inte att veta. Därför använder man i R istället is.na() för att undersöka om något är NA. is.na(x) ## [1] FALSE TRUE FALSE FALSE NA är ett vanligt argument i funktioner. Ska vi exempelvis beräkna medelvärdet på vår vektor x som har NA i sig så får vi: mean(x) ## [1] NA Eftersom vi saknar ett värde kan vi omöjligen veta vad medelvärdet för x är. Det saknade värdet kan vara vilken siffra som helst. Därför kan vi i funktionen mean() välja att helt bortse från det saknade värdet: mean(x, na.rm = TRUE) ## [1] 18.66667 2.2 R är ett funktionellt programmeringsspråk Vi använder oss hela tiden av funktioner i R. Vi kan skriva egna funktioner men oftast använder vi färdiga funktioner från paket med funktioner. Funktionell programmering är bra för dataanalys. Ofta jobbar vi med data som vi vill manipulera om och om igen och funktioner är ett bra sätt att göra det på. På många sätt liknar R därför Excel som också jobbar mycket med funktioner. 2.2.1 Funktioner Precis som i Excel finns det flertalet inbyggda statistiska och matematiska funktioner i R: mean() median() sd() …osv Det finns också matematiska funktioner log() sin() cos() …osv 2.2.2 Dokumentation av funktioner Funktioner innehåller också dokumentation om hur de fungerar. För att komma åt dokumentation skriver du ett frågetecken innan funktioner. ?mean() 2.2.3 Övning Använd några av R:s statistiska funktioner på en numerisk vektor 2.3 Data frames Det vanligaste formatet i R för dataanalys En data.frame är en rektangulär tabell med en eller flera kolumner year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time arr_delay carrier flight tailnum origin dest air_time distance hour minute time_hour 2013 1 1 517 515 2 830 819 11 UA 1545 N14228 EWR IAH 227 1400 5 15 2013-01-01 05:00:00 2013 1 1 533 529 4 850 830 20 UA 1714 N24211 LGA IAH 227 1416 5 29 2013-01-01 05:00:00 2013 1 1 542 540 2 923 850 33 AA 1141 N619AA JFK MIA 160 1089 5 40 2013-01-01 05:00:00 2013 1 1 544 545 -1 1004 1022 -18 B6 725 N804JB JFK BQN 183 1576 5 45 2013-01-01 05:00:00 2013 1 1 554 600 -6 812 837 -25 DL 461 N668DN LGA ATL 116 762 6 0 2013-01-01 06:00:00 2013 1 1 554 558 -4 740 728 12 UA 1696 N39463 EWR ORD 150 719 5 58 2013-01-01 05:00:00 Vi kan enkelt skapa våra egna data.frames. data.frame(random_number = rnorm(5)) ## random_number ## 1 -1.6992399 ## 2 0.9755193 ## 3 -1.4807371 ## 4 -1.2570500 ## 5 -0.1507325 En data.frame är ett bra sätt att spara en eller flera vektorer. De måste då vara exakt lika långa. data.frame(x = c(1,2,3), y = c(&quot;hej&quot;, &quot;på&quot;, &quot;dig&quot;)) ## x y ## 1 1 hej ## 2 2 på ## 3 3 dig Om du sparar vektorerna som två objekt kan du enkelt göra dem till den data.frame. siffror &lt;- c(5,1,2,5) ord &lt;- c(&quot;vad&quot;, &quot;var&quot;, &quot;det&quot;, &quot;där&quot;) data.frame(siffror, ord) ## siffror ord ## 1 5 vad ## 2 1 var ## 3 2 det ## 4 5 där 2.4 Paket Vi nämnde tidigare att vi kan spara funktioner i så kallade paket. Paket är precis det. Ett sätt för oss att spara och lätt komma åt funktioner i R. Paket som genomgår viss granskning läggs upp på CRAN (The Comprehensive R Archive Network). Men man kan även skapa egna paket och lägga upp på Github eller spara på sin egen dator. För att installera ett paket från CRAN använder du funktionen install.packages(&quot;paketnamn&quot;). När du sedan laddat ner paketet behöver du ladda det i R genom library(paketnamn). 2.4.1 Övning Paketet tidyverse är nedladdat åt dig. Ladda paketet med library() 2.5 tidyverse and friends tidyverse är en samling paket för att lösa olika typer av problem inom dataanalys. De har en gemensam filosofi: paketen och dess funktioner är i första hand designade för att människor ska använda dem. Det gör att de av många upplevs som enklare att använda och mer konsekventa än det som kallas base R . D.v.s. R utan några paket. Vi kommer här att fokusera på tidyverse eftersom det är ett bra sätt att komma igång med R. 2.6 Workflow i R I R så jobbar vi med så kallade R-projects. I Rstudio kan du klicka på file -&gt; New Project -&gt; New Directory -&gt; Create Project för att skapa ett nytt projekt. Genom att skapa ett projekt vet R alltid var filerna för det projektet är och det blir enklare för dig att jobba. 2.7 Att skriva kod i R När du skriver kod gör du det dels med hänsyn dels till andra men framför allt med hänsyn till ditt framtida jag. Koden ska med andra ord vara enkel att läsa. Därför kan det vara bra att följa en stilguide. Jag följer stilguiden från tidyverse som säger att: Namnge alltid variabler, objekt m.m. med små bokstäver. Exempelvis är det enklare att läsa: min_egna_funktion &lt;- function(x) I kontrast till: MinEgnaFunktion &lt;- function(x) Vi strävar dessutom efter att skriva kod som vi skriver text, med mellanrum mellan , och ord. Det här är enklare att läsa: mean(x, na.rm = TRUE) Än det här: mean(x,na.rm=TRUE) När vi sparar filer så försöker vi följa den här syntaxen. Därför ska du inte ha mellanrum i när du sparar filer. min-r-fil.R är bra men min R fil.R är dåligt. När vi skriver kod försöker vi dessutom inte att skriva för lång uttryck: Det här är mycket svårare att läsa: iris %&gt;% group_by(Species) %&gt;% summarise(Sepal.Length = mean(Sepal.Length), Sepal.Width = mean(Sepal.Width), Species = n_distinct(Species)) Än det här: iris %&gt;% group_by(Species) %&gt;% summarise( Sepal.Length = mean(Sepal.Length), Sepal.Width = mean(Sepal.Width), Species = n_distinct(Species) ) 2.8 Rmarkdown Rmarkdown är ett format som tillåter dig varva r-kod med skriven text. Du kan sedan rendera filen till antigen HTML, PDF, Word, PowerPoint samt en rad andra format. "],
["datamanipulering-med-dplyr.html", "Kapitel 3 Datamanipulering med dplyr 3.1 Filter 3.2 Arrange 3.3 Select 3.4 Mutate 3.5 Summarise 3.6 sample_n()", " Kapitel 3 Datamanipulering med dplyr Det sägs ofta att en Data Scientist ägnar 80% av sin tid till att manipulera data så att den går att visualisera och modellera. Därför är det klokt att välja en metod och ett paket som underlättar det arbetet för dig. I den här introduktionen kommer vi att fokusera på att använda paketet dplyr för att göra datamanipuleringar. dplyr är ett av de mest populära paketen i R och ger dig en bred verktygslåda för att manipulera data. dplyr ingår också i ett samlingspaket tidyverse och samlar flertalet paket för datamanipulering, visualisering och modellering. dplyr har ett antal verb för att göra manipuleringar: filter() där du väljer observationer baserat på deras värden arrange() som ändrar ordningen på rader select() för att välja variabler baserat på deras namn mutate() för att skapa nya variabler baserat på funktioner summarise() för att summera många värden till ett värde Samtliga av dessa verb kan användas i kombination med funktionen group_by() som innebär att du utför verben på flera grupper. Alla verb i dplyr är konsekventa. Det första argumentet är din data och i det andra argumentet specificerar du vad du vill göra med din data. Resultatet är alltid en ny data.frame. 3.1 Filter Med filter kan du enkelt filtrera din data baserat på villkor. Dessa villkor uttrycks med hjälp av relationsoperatorer och logical operators. I R är dessa: Relationsoperator Symbol i R och (and) &amp; eller(or) | icke(not) ! Logical Operators Symbol i R lika == inte lika != större än eller lika &gt;= mindre än eller lika &lt;= större än &gt; mindre än &lt; finns i %in% Dessa kan du använda i filter(). PS: Det vanligaste misstaget i början av din R-karriär är att skriva = istället för ==. Så här använder du operatorerna: Hitta alla flyg som kom fram 08:30 under februari library(dplyr) library(nycflights13) filter(flights, month == 2, arr_time == 830) ## # A tibble: 9 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013 2 2 656 700 -4 830 ## 2 2013 2 4 652 600 52 830 ## 3 2013 2 6 629 630 -1 830 ## 4 2013 2 13 633 636 -3 830 ## 5 2013 2 18 717 700 17 830 ## 6 2013 2 24 557 600 -3 830 ## 7 2013 2 25 532 540 -8 830 ## 8 2013 2 26 615 615 0 830 ## 9 2013 2 28 621 630 -9 830 ## # … with 12 more variables: sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, ## # time_hour &lt;dttm&gt; Hitta alla flygbolag som finns i c(&quot;UA&quot;, &quot;DL&quot;) i februari eller mars och som inte var försenade. filter(flights, carrier %in% c(&quot;UA&quot;, &quot;DL&quot;), month == 2 | month == 3, dep_delay &lt;= 0) ## # A tibble: 10,346 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013 2 1 520 525 -5 816 ## 2 2013 2 1 527 530 -3 837 ## 3 2013 2 1 554 601 -7 920 ## 4 2013 2 1 558 600 -2 738 ## 5 2013 2 1 559 600 -1 923 ## 6 2013 2 1 600 600 0 833 ## 7 2013 2 1 601 608 -7 703 ## 8 2013 2 1 601 608 -7 723 ## 9 2013 2 1 604 610 -6 752 ## 10 2013 2 1 608 615 -7 837 ## # … with 10,336 more rows, and 12 more variables: sched_arr_time &lt;int&gt;, ## # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, ## # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, ## # minute &lt;dbl&gt;, time_hour &lt;dttm&gt; 3.1.1 Övning Hur många plan… var försenade mer än 1 timme? skulle till Boston (“BOS”) lämnade JFK och var försenade lämnade JFK på julafton var försenade, men inte kom fram försent flög United Airlines (UA) eller American Airlines? 3.2 Arrange arrange() kastar om ordningen på dina rader enligt en av dig vald variabel. Exempelvis kanske vi vill sortera data på försenade avgångar dep_delay. arrange(flights, dep_delay) ## # A tibble: 336,776 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013 12 7 2040 2123 -43 40 ## 2 2013 2 3 2022 2055 -33 2240 ## 3 2013 11 10 1408 1440 -32 1549 ## 4 2013 1 11 1900 1930 -30 2233 ## 5 2013 1 29 1703 1730 -27 1947 ## 6 2013 8 9 729 755 -26 1002 ## 7 2013 10 23 1907 1932 -25 2143 ## 8 2013 3 30 2030 2055 -25 2213 ## 9 2013 3 2 1431 1455 -24 1601 ## 10 2013 5 5 934 958 -24 1225 ## # … with 336,766 more rows, and 12 more variables: sched_arr_time &lt;int&gt;, ## # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, ## # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, ## # minute &lt;dbl&gt;, time_hour &lt;dttm&gt; arrange() sorterar per default på sjunkande värde (ascending). Vill du sortera på stigande värde (descending) sätter du desc() runt din variabel. arrange(flights, desc(dep_delay)) ## # A tibble: 336,776 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013 1 9 641 900 1301 1242 ## 2 2013 6 15 1432 1935 1137 1607 ## 3 2013 1 10 1121 1635 1126 1239 ## 4 2013 9 20 1139 1845 1014 1457 ## 5 2013 7 22 845 1600 1005 1044 ## 6 2013 4 10 1100 1900 960 1342 ## 7 2013 3 17 2321 810 911 135 ## 8 2013 6 27 959 1900 899 1236 ## 9 2013 7 22 2257 759 898 121 ## 10 2013 12 5 756 1700 896 1058 ## # … with 336,766 more rows, and 12 more variables: sched_arr_time &lt;int&gt;, ## # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, ## # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, ## # minute &lt;dbl&gt;, time_hour &lt;dttm&gt; 3.2.1 Övning Hitta det flyg som… flög längst var mest försenat (när det kom fram) 3.3 Select Medan arrange() kastar om raderna så kastar select() om kolumnerna. Men mest används den för att välja ut kolumner av intresse. select(flights, dep_delay, carrier) ## # A tibble: 336,776 x 2 ## dep_delay carrier ## &lt;dbl&gt; &lt;chr&gt; ## 1 2 UA ## 2 4 UA ## 3 2 AA ## 4 -1 B6 ## 5 -6 DL ## 6 -4 UA ## 7 -5 B6 ## 8 -3 EV ## 9 -3 B6 ## 10 -2 AA ## # … with 336,766 more rows Om du av något skäl vill flytta en kolumn till början kan du skriva: select(flights, carrier, everything()) ## # A tibble: 336,776 x 19 ## carrier year month day dep_time sched_dep_time dep_delay arr_time ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 UA 2013 1 1 517 515 2 830 ## 2 UA 2013 1 1 533 529 4 850 ## 3 AA 2013 1 1 542 540 2 923 ## 4 B6 2013 1 1 544 545 -1 1004 ## 5 DL 2013 1 1 554 600 -6 812 ## 6 UA 2013 1 1 554 558 -4 740 ## 7 B6 2013 1 1 555 600 -5 913 ## 8 EV 2013 1 1 557 600 -3 709 ## 9 B6 2013 1 1 557 600 -3 838 ## 10 AA 2013 1 1 558 600 -2 753 ## # … with 336,766 more rows, and 11 more variables: sched_arr_time &lt;int&gt;, ## # arr_delay &lt;dbl&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, ## # dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, ## # time_hour &lt;dttm&gt; Du kan även välja alla kolumner mellan två kolumner: select(flights, year:day) ## # A tibble: 336,776 x 3 ## year month day ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 ## 2 2013 1 1 ## 3 2013 1 1 ## 4 2013 1 1 ## 5 2013 1 1 ## 6 2013 1 1 ## 7 2013 1 1 ## 8 2013 1 1 ## 9 2013 1 1 ## 10 2013 1 1 ## # … with 336,766 more rows Genom att sätta ett minus framför variabelnamnet exkluderar du variabeln. select(flights, -year) ## # A tibble: 336,776 x 18 ## month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 1 1 517 515 2 830 819 ## 2 1 1 533 529 4 850 830 ## 3 1 1 542 540 2 923 850 ## 4 1 1 544 545 -1 1004 1022 ## 5 1 1 554 600 -6 812 837 ## 6 1 1 554 558 -4 740 728 ## 7 1 1 555 600 -5 913 854 ## 8 1 1 557 600 -3 709 723 ## 9 1 1 557 600 -3 838 846 ## 10 1 1 558 600 -2 753 745 ## # … with 336,766 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, ## # time_hour &lt;dttm&gt; 3.3.0.1 select() plus hjälpfunktioner select() kommer med ett antal hjälpfunktioner: starts_with(&quot;asd&quot;) ends_with(&quot;air&quot;) contains(&quot;flyg&quot;) matches(&quot;asd&quot;) num_range(&quot;flyg&quot;, 1:10) De används för att identifiera kolumner baserat på text. Exempelvis kan du hitta alla delay-kolumner med contains. select(flights, contains(&quot;delay&quot;)) ## # A tibble: 336,776 x 2 ## dep_delay arr_delay ## &lt;dbl&gt; &lt;dbl&gt; ## 1 2 11 ## 2 4 20 ## 3 2 33 ## 4 -1 -18 ## 5 -6 -25 ## 6 -4 12 ## 7 -5 19 ## 8 -3 -14 ## 9 -3 -8 ## 10 -2 8 ## # … with 336,766 more rows 3.3.0.2 rename() En annan nyttig funktion är rename() som kort och gott döper om variabler. Formeln är rename(data, ny_variabel = gammal_variabel) 3.3.1 Övning Som innehåller “dep” Som börjar med “dep” Döp om dep_delay till försenad_avgång 3.4 Mutate mutate() används för att skapa nya variabler. Exempelvis kan vi räkna ut hur mycket tid man vunnit om exempelvis flyget landar tidigare än avsett. mutate(flights, beer_time = dep_delay - arr_delay) ## # A tibble: 336,776 x 20 ## year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 ## 2 2013 1 1 533 529 4 850 ## 3 2013 1 1 542 540 2 923 ## 4 2013 1 1 544 545 -1 1004 ## 5 2013 1 1 554 600 -6 812 ## 6 2013 1 1 554 558 -4 740 ## 7 2013 1 1 555 600 -5 913 ## 8 2013 1 1 557 600 -3 709 ## 9 2013 1 1 557 600 -3 838 ## 10 2013 1 1 558 600 -2 753 ## # … with 336,766 more rows, and 13 more variables: sched_arr_time &lt;int&gt;, ## # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, ## # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, ## # minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, beer_time &lt;dbl&gt; I mutate() kan du även använda funktioner såsom mean(). mutate(flights, mean_delay = mean(dep_delay, na.rm = T)) ## # A tibble: 336,776 x 20 ## year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 ## 2 2013 1 1 533 529 4 850 ## 3 2013 1 1 542 540 2 923 ## 4 2013 1 1 544 545 -1 1004 ## 5 2013 1 1 554 600 -6 812 ## 6 2013 1 1 554 558 -4 740 ## 7 2013 1 1 555 600 -5 913 ## 8 2013 1 1 557 600 -3 709 ## 9 2013 1 1 557 600 -3 838 ## 10 2013 1 1 558 600 -2 753 ## # … with 336,766 more rows, and 13 more variables: sched_arr_time &lt;int&gt;, ## # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, ## # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, ## # minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, mean_delay &lt;dbl&gt; 3.4.1 if_else() En vanlig funktion i databearbetning är ifelse-satser. I R gör du det enklast med funktionen if_else() från dplyr. Det finns även en inbyggd funktion som heter ifelse() som mestadels fungerar bra men den från dplyr är något mer stabil. Du kan använda den i mutate: mutate(flights, försenad = if_else(dep_delay &gt; 5, &quot;försenad&quot;, &quot;ej försenad&quot;)) ## # A tibble: 336,776 x 20 ## year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 ## 2 2013 1 1 533 529 4 850 ## 3 2013 1 1 542 540 2 923 ## 4 2013 1 1 544 545 -1 1004 ## 5 2013 1 1 554 600 -6 812 ## 6 2013 1 1 554 558 -4 740 ## 7 2013 1 1 555 600 -5 913 ## 8 2013 1 1 557 600 -3 709 ## 9 2013 1 1 557 600 -3 838 ## 10 2013 1 1 558 600 -2 753 ## # … with 336,766 more rows, and 13 more variables: sched_arr_time &lt;int&gt;, ## # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, ## # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, ## # minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, försenad &lt;chr&gt; Ibland vill man göra flera stycken if_else() i samma, exempelvis om man vill dela upp en variabel i flera kategorier beroende på ett logiskt villkor. För att göra det kan du använda funktionen case_when(). mutate(flights, försenad_kat = case_when( dep_delay &lt; 0 ~ &quot;före tid&quot;, dep_delay == 0 ~ &quot;i tid&quot;, dep_delay &gt; 0 ~ &quot;försenad&quot;)) ## # A tibble: 336,776 x 20 ## year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 ## 2 2013 1 1 533 529 4 850 ## 3 2013 1 1 542 540 2 923 ## 4 2013 1 1 544 545 -1 1004 ## 5 2013 1 1 554 600 -6 812 ## 6 2013 1 1 554 558 -4 740 ## 7 2013 1 1 555 600 -5 913 ## 8 2013 1 1 557 600 -3 709 ## 9 2013 1 1 557 600 -3 838 ## 10 2013 1 1 558 600 -2 753 ## # … with 336,766 more rows, and 13 more variables: sched_arr_time &lt;int&gt;, ## # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, ## # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, ## # minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, försenad_kat &lt;chr&gt; 3.4.2 Andra funktioner I mutate() kan du använda de allra flesta funktionerna i R. Här är exempel på några funktioner som kan vara nyttiga i databearbetning: Funktioner för att ranka variabler: rank(), min_rank(), dense_rank(), percent_rank() För att logaritmiska funktioner: log(), log10() För kumulativa beräkningar: cumsum(), cummean() För att bara generera radnummer: row_number() För att ta observation innan eller efter: lead() och lag() För skapa variabler baserat på värde i andra variabler if_else() och case_when() 3.4.3 Övningar Skapa en variabel som innehåller den totala förseningen Rangordna flygens distans. Hur hanterar du fall där distansen är lika lång? Skapa en variabel som anger om flyget går på våren, hösten, vintern eller sommaren. 3.5 Summarise Ofta vill man summera variabler för att få ut intressant information. Exempelvis vill vi här kanske veta en rad medelvärden. summarise(flights, mean_dist = mean(distance, na.rm = T)) ## # A tibble: 1 x 1 ## mean_dist ## &lt;dbl&gt; ## 1 1040. summarise(flights, sum_dist = sum(distance, na.rm = T)) ## # A tibble: 1 x 1 ## sum_dist ## &lt;dbl&gt; ## 1 350217607 summarise(flights, count = n()) ## # A tibble: 1 x 1 ## count ## &lt;int&gt; ## 1 336776 Men dessa värden är inte så intressanta i sig, utan vi vill kunna göra jämförelse. Då använder vi group_by(). group_by_flights &lt;- group_by(flights, carrier) summarise(group_by_flights, mean_air_time = mean(air_time, na.rm = T), mean_dep_delay = mean(dep_delay, na.rm = T), mean_arr_delay = mean(arr_delay, na.rm = T)) ## # A tibble: 16 x 4 ## carrier mean_air_time mean_dep_delay mean_arr_delay ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 9E 86.8 16.7 7.38 ## 2 AA 189. 8.59 0.364 ## 3 AS 326. 5.80 -9.93 ## 4 B6 151. 13.0 9.46 ## 5 DL 174. 9.26 1.64 ## 6 EV 90.1 20.0 15.8 ## 7 F9 230. 20.2 21.9 ## 8 FL 101. 18.7 20.1 ## 9 HA 623. 4.90 -6.92 ## 10 MQ 91.2 10.6 10.8 ## 11 OO 83.5 12.6 11.9 ## 12 UA 212. 12.1 3.56 ## 13 US 88.6 3.78 2.13 ## 14 VX 337. 12.9 1.76 ## 15 WN 148. 17.7 9.65 ## 16 YV 65.7 19.0 15.6 I summarise() kan du använda en rad olika funktioner såsom sum() för summeringar, median() etc. 3.5.0.1 Övningar Vilken flygplats har högst medelvärde förförseningar från flygplatsen? Vilken flygplats tar emot minst flyg? 3.5.0.2 Väv ihop verben med %&gt;% Med %&gt;% (som kallas för pipe and kan uttalas som and then) kan länka ihop flera uttryck i R. Det gör framför allt din kod mer lättläst. Med %&gt;% kan du exempelvis först filtrera, sen gruppera och till sist summera, allt i samma uttryck. flights %&gt;% filter(dep_delay &lt; 60) %&gt;% group_by(carrier) %&gt;% summarise(mean_dep_delay = mean(dep_delay, na.rm = T)) ## # A tibble: 16 x 2 ## carrier mean_dep_delay ## &lt;chr&gt; &lt;dbl&gt; ## 1 9E 2.96 ## 2 AA 0.890 ## 3 AS -0.719 ## 4 B6 3.26 ## 5 DL 1.76 ## 6 EV 4.65 ## 7 F9 5.09 ## 8 FL 4.72 ## 9 HA -2.47 ## 10 MQ 1.48 ## 11 OO -2.88 ## 12 UA 4.33 ## 13 US -0.744 ## 14 VX 2.70 ## 15 WN 6.60 ## 16 YV 2.25 Du läser alltså: Första tar vi flights and then filtrerar vi på dep_delay and then grupperar vi på carrier and then räknar vi ut medelvärde på dep_delay. Vilket är mycket mer lättläst än motsvarigheten med parenteser: summarise( group_by( filter(flights, dep_delay &gt; 60), carrier), mean_dep_delay = mean(dep_delay, na.rm = T)) 3.5.0.3 count() Du kan i summarise() räkna antalet observationer med funktionen n(). flights %&gt;% group_by(carrier) %&gt;% summarise(count = n()) ## # A tibble: 16 x 2 ## carrier count ## &lt;chr&gt; &lt;int&gt; ## 1 9E 18460 ## 2 AA 32729 ## 3 AS 714 ## 4 B6 54635 ## 5 DL 48110 ## 6 EV 54173 ## 7 F9 685 ## 8 FL 3260 ## 9 HA 342 ## 10 MQ 26397 ## 11 OO 32 ## 12 UA 58665 ## 13 US 20536 ## 14 VX 5162 ## 15 WN 12275 ## 16 YV 601 Men istället för att göra det här kan du använda funktionen count() flights %&gt;% group_by(carrier) %&gt;% count() ## # A tibble: 16 x 2 ## # Groups: carrier [16] ## carrier n ## &lt;chr&gt; &lt;int&gt; ## 1 9E 18460 ## 2 AA 32729 ## 3 AS 714 ## 4 B6 54635 ## 5 DL 48110 ## 6 EV 54173 ## 7 F9 685 ## 8 FL 3260 ## 9 HA 342 ## 10 MQ 26397 ## 11 OO 32 ## 12 UA 58665 ## 13 US 20536 ## 14 VX 5162 ## 15 WN 12275 ## 16 YV 601 3.6 sample_n() Att göra slumpmässiga urval är en vanlig arbetsuppgift för en data scientist. Det gör du enkelt med sample_n() från dplyr. Om du vill ta ett slumpmässigt urval om 10 från exempelvis flights gör du bara: sample_n(flights, 10) ## # A tibble: 10 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013 4 19 1858 1825 33 2307 ## 2 2013 7 27 1522 1520 2 1736 ## 3 2013 7 19 1053 1100 -7 1328 ## 4 2013 9 17 826 830 -4 1020 ## 5 2013 8 6 1716 1720 -4 1850 ## 6 2013 11 3 1725 1730 -5 2013 ## 7 2013 3 21 1810 1815 -5 1948 ## 8 2013 9 17 752 800 -8 912 ## 9 2013 7 12 1651 1655 -4 1821 ## 10 2013 1 20 1257 1300 -3 1510 ## # … with 12 more variables: sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, ## # time_hour &lt;dttm&gt; Om du istället vill ta ett urval som baseras på procent kan du använda sample_frac, här för 0.01% sample_frac(flights, 0.001) ## # A tibble: 337 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013 4 5 2036 2035 1 2343 ## 2 2013 4 21 846 850 -4 1252 ## 3 2013 2 18 626 630 -4 812 ## 4 2013 6 2 1445 1445 0 1734 ## 5 2013 7 9 1136 1125 11 1359 ## 6 2013 2 25 532 530 2 854 ## 7 2013 12 31 1713 1650 23 1935 ## 8 2013 12 15 NA 755 NA NA ## 9 2013 9 11 1227 1159 28 1512 ## 10 2013 1 18 1500 1457 3 1817 ## # … with 327 more rows, and 12 more variables: sched_arr_time &lt;int&gt;, ## # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, ## # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, ## # minute &lt;dbl&gt;, time_hour &lt;dttm&gt; 3.6.1 Övning Vilken månad ska du flyga under för att undvika förseningar? Vilken tid ska du flyga för att undvika förseningar? Hitta det flygbolag som flyger till flest destinationer, rangordna flygbolagen baserat på den informationen. "],
["bilaga.html", "Kapitel 4 Bilaga 4.1 Variabeltyper i R 4.2 Indexering", " Kapitel 4 Bilaga 4.1 Variabeltyper i R De variabeltyper som finns i R är: Beskrivning Synonymer typeof() Exempel Heltal int, numeric integer -2, 0, 1 Reella tal real, double, float, numeric double 1.03, 0.22 Komplexa tal cplx complex 1+2i Logiska värden booelan, bool, logi logical TRUE, FALSE Faktorer factors fctr “Women” Datum dates date “2017-02-04” Text string, char character “Hello R!” flights är en så kallad data.frame som egentligen är en samling vektorer. data.frame är den vanligaste data-typen i R för att arbeta med data. Om du är nyfiken på att undersöka variabeltypen, eller klassen, på ett objekt eller en kolumn kan du använda funktionen class() class(x) ## [1] &quot;numeric&quot; class(text) ## [1] &quot;character&quot; 4.1.1 Vektorer Vektorer är ett objekt i R som innehåller en eller flera element. En vektor kan endast innehålla en typ av variabel. Det vanligaste sättet att skapa en vektor är genom c(). # Numerisk vektor numvec &lt;- c(1,4,7) # Textvektor charvec &lt;- c(&quot;Kalle&quot;, &quot;Anka&quot;) 4.1.2 Faktorvariabel En annan typ av variabel är den såkallade faktorer, factor. Faktorer är kategoriska variabler som har olika nivåer som representerar fakta. Kön eller åldersgrupp är exempel på faktorer. # minText är en textvektor min_text &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;A&quot;, &quot;A&quot;) # Konvertera minText till faktorvariabel med as.factor min_faktor &lt;- as.factor(min_text) min_faktor ## [1] A B A A ## Levels: A B # För att undersöka klassen av vektorn minFaktor class(min_faktor) ## [1] &quot;factor&quot; # För att undersöka vilka unika värden finns på minFaktor levels(min_faktor) ## [1] &quot;A&quot; &quot;B&quot; 4.1.3 Logik Logiska värdena förekommer ofta i programmeringsvärlden. De logiska värdena i R är: TRUE, FALSE och NA. 4.1.3.1 Logiska operatorer Logiska operatorer är de operatorer som bara kan användas på logiska vektorer. Det kallas även för boolsk algebra. De viktigaste operatorerna i R visas i tabellen nedan. Operator Symbol i R och (and) &amp; eller(or) | icke(not) ! 4.1.3.2 Relationsoperatorer Man vill ofta jämföra olika vektorer för att sedan indexera en datamängd. Detta görs med hjälp av relationsoperatorer som beskrivs nedan. Använder relationsoperatorer för att jämföra olika variabler. Relationsoperatorer returnerar logiska värde. Logiska värdena används sedan för indexering. De vanligaste relationsoperatorer i R är följande: Relationsoperatorer Symbol i R lika == inte lika != större än eller lika &gt;= mindre än eller lika &lt;= större än &gt; mindre än &lt; finns i %in% 4.1.4 Matriser Matriser är också en av de vanligaste datastruktur i R. Den har två dimensioner, rader och kolumner. Likt som vektorer så kan matriser bara innehålla en typ av element. Det innebär att en matris kan endast vara en textmatris, numerisk matris eller logisk matris. Matriserna kan skapas enkelt i R med funktionen matrix(). min_matris &lt;- matrix(data=c(1,2,3,4), nrow=2) min_matris ## [,1] [,2] ## [1,] 1 3 ## [2,] 2 4 4.1.5 Data.frame data.frame är en tabell som innehåller flera olika typer av variabler. Det är egentligen en samling av vektorer, därför kan en data.frame innehålla olika typer av vektorer som numeriska, logiska, textsträngar och faktorer. För att skapa ett dataset i R används funktionen data.frame() df &lt;- data.frame(num = 1:3, text = rep(&quot;Text&quot;, 3), logi=c(TRUE, TRUE, FALSE)) df ## num text logi ## 1 1 Text TRUE ## 2 2 Text TRUE ## 3 3 Text FALSE Det finns ett antal förinstallerade data frames i R som du kan använda, det är även vanligt med paket vars enda syfte är att innehålla data. För att kolla upp vilka data frames som finns förinstallerade kan du använda funktionen data(). data() # För att läsa in en data.frame i Global Environment så skriv namn av data inom parentesen data(iris) iris 4.1.5.1 $ Även om dplyr är att föredra för datamanipuleringar är det bra att veta att det går att göra samma manipuleringar i R men med en annan syntax. Då använder man i princip endast de inbyggda paketen (ofta kallade för base) som laddas mer R. En viktig operatör i base-R är $ (extract-operator) som extraherar värden från objekt baserat på namn. Exempelvis mtcars$cyl ## [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4 Med $ kan du också skapa nya variabler. mtcars$ny_variabel &lt;- mtcars$mpg / mtcars$cyl Eller döpa om variabler mtcars$mpg_med_konstigt_namn &lt;- mtcars$mpg 4.1.5.2 colnames() Om du vill ha dina kolumnnamn som en vektor kan du extrahera dessa med colnames(). colnames(mtcars) ## [1] &quot;mpg&quot; &quot;cyl&quot; ## [3] &quot;disp&quot; &quot;hp&quot; ## [5] &quot;drat&quot; &quot;wt&quot; ## [7] &quot;qsec&quot; &quot;vs&quot; ## [9] &quot;am&quot; &quot;gear&quot; ## [11] &quot;carb&quot; &quot;ny_variabel&quot; ## [13] &quot;mpg_med_konstigt_namn&quot; Ibland kanske du har en lista på variabelnamn som du vill att data ska ha. kolumnnamn &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;) Då kan du applicera colnames() med din vektor på din data.frame. colnames(mtcars) &lt;- kolumnnamn mtcars ## A B C D E F G H I J K NA ## Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 3.500000 ## Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 3.500000 ## Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 5.700000 ## Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 3.566667 ## Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 2.337500 ## Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 3.016667 ## Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 1.787500 ## Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 6.100000 ## Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 5.700000 ## Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 3.200000 ## Merc 280C 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 2.966667 ## Merc 450SE 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 2.050000 ## Merc 450SL 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 2.162500 ## Merc 450SLC 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 1.900000 ## Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 1.300000 ## Lincoln Continental 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 1.300000 ## Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 1.837500 ## Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 8.100000 ## Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 7.600000 ## Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 8.475000 ## Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 5.375000 ## Dodge Challenger 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 1.937500 ## AMC Javelin 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 1.900000 ## Camaro Z28 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 1.662500 ## Pontiac Firebird 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2 2.400000 ## Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 6.825000 ## Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 6.500000 ## Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 7.600000 ## Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4 1.975000 ## Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 3.283333 ## Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8 1.875000 ## Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 5.350000 ## NA ## Mazda RX4 21.0 ## Mazda RX4 Wag 21.0 ## Datsun 710 22.8 ## Hornet 4 Drive 21.4 ## Hornet Sportabout 18.7 ## Valiant 18.1 ## Duster 360 14.3 ## Merc 240D 24.4 ## Merc 230 22.8 ## Merc 280 19.2 ## Merc 280C 17.8 ## Merc 450SE 16.4 ## Merc 450SL 17.3 ## Merc 450SLC 15.2 ## Cadillac Fleetwood 10.4 ## Lincoln Continental 10.4 ## Chrysler Imperial 14.7 ## Fiat 128 32.4 ## Honda Civic 30.4 ## Toyota Corolla 33.9 ## Toyota Corona 21.5 ## Dodge Challenger 15.5 ## AMC Javelin 15.2 ## Camaro Z28 13.3 ## Pontiac Firebird 19.2 ## Fiat X1-9 27.3 ## Porsche 914-2 26.0 ## Lotus Europa 30.4 ## Ford Pantera L 15.8 ## Ferrari Dino 19.7 ## Maserati Bora 15.0 ## Volvo 142E 21.4 4.1.6 Listor Listor är mer generell datastruktur i R. Man kan jämföra lista med en “låda” som innehåller olika datastrukter i R. En lista kan innehålla vektorer, data.frame och matriser, i olika längd och storlek, samtidigt. För att skapa en lista används funktionen list() # skapar vektorer a, b, c a &lt;- c(&quot;hej&quot;, &quot;Kalle&quot;, &quot;hejdå&quot;) b &lt;- c(TRUE, FALSE, FALSE, TRUE) c &lt;- 1:8 x &lt;- list(a,b,c) x ## [[1]] ## [1] &quot;hej&quot; &quot;Kalle&quot; &quot;hejdå&quot; ## ## [[2]] ## [1] TRUE FALSE FALSE TRUE ## ## [[3]] ## [1] 1 2 3 4 5 6 7 8 Ett mycket vanligt exempel på en lista är modellobjekt, dvs objektet man skapar när man anpassar en modell, till exempel en regressionsmodell. Hela resultatet från modellanpassningen ligger på en lista. Se nedan. # Skapar en data.frame ctl &lt;- c(4.17,5.58,5.18,6.11,4.50,4.61,5.17,4.53,5.33,5.14) trt &lt;- c(4.81,4.17,4.41,3.59,5.87,3.83,6.03,4.89,4.32,4.69) group &lt;- gl(2, 10, 20, labels = c(&quot;Ctl&quot;,&quot;Trt&quot;)) weight &lt;- c(ctl, trt) # Linjär regression. lm &lt;- lm(weight ~ group) is.list(lm) ## [1] TRUE # Vilka element eller objekt som finns i listan lm? attributes(lm) ## $names ## [1] &quot;coefficients&quot; &quot;residuals&quot; &quot;effects&quot; &quot;rank&quot; ## [5] &quot;fitted.values&quot; &quot;assign&quot; &quot;qr&quot; &quot;df.residual&quot; ## [9] &quot;contrasts&quot; &quot;xlevels&quot; &quot;call&quot; &quot;terms&quot; ## [13] &quot;model&quot; ## ## $class ## [1] &quot;lm&quot; lm är en lista som innehåller bland annat regressions koefficienter, residualer, anpassade värden, mm. 4.1.7 Datum I R uttrycks datum som antal dagar från 1970-01-01. Datum som kommer innan det skrivs ut som negativa värde. minaDatum &lt;- as.Date(c(&quot;2018-08-14&quot;, &quot;1970-01-01&quot;)) minaDatum[1] - minaDatum[2] ## Time difference of 17757 days as.Date(17757, origin = &quot;1970-01-01&quot;) ## [1] &quot;2018-08-14&quot; Sys.Date() ger dagens datum. date() returnerar dagens veckodag, datum och tid. 4.1.7.1 Olika datumformat Symbol i R Betydelse Exempel %d dagnummer 01-31 %a förkortad veckodag Mon %A full veckodag Monday %m månad nummer 00-12 %b förkortad månad Jan %B full månad January %y 2 siffrig år 18 %Y 4 siffrig år 2018 4.1.7.2 Formatera datum idag &lt;- Sys.Date() format_idag &lt;- format(idag, format = &quot;%B %d %Y&quot;) format_idag ## [1] &quot;October 14 2019&quot; format(minaDatum[2], format=&quot;%m/%d/%y&quot;) ## [1] &quot;01/01/70&quot; 4.2 Indexering Ibland är man bara intresserad av en kolumn eller enstaka värde. För att indexera eller plocka ut specifikt element ur ett objekt kan man använda sig av hackparentes [] eller dollar tecken $ och detta görs på olika sätt. ### Genom att ange positions nummer #Vektor testScore &lt;- c(7, 15, 20, 20, 23, 1.2) testScore[3] #tredje element ## [1] 20 testScore[-1] #alla utom den första ## [1] 15.0 20.0 20.0 23.0 1.2 Kör koden nedan för att se resultatet. #Data.frame. data(iris) iris[, 1] # Väljer kolumn nummer 1 iris[1:5, c(1,2)] # Rad 1 till 5 på Kolumn 1 och 2 4.2.1 Genom att begränsa värden som man vill plocka ut # Vektor testScore[testScore &lt; 10] # alla som är mindre än 10 ## [1] 7.0 1.2 testScore[testScore == 20] # alla som är lika med 20 ## [1] 20 20 Kör koden nedan för att se resultatet. # Data.frame head(iris[iris[,1] &gt; 7,]) # alla observationer där kolumn nummer 1 är större än 7. Funktionen head() används för att minimera rader som skrivs ut. 4.2.2 Genom att ange namn av elementet eller kolumnen Det går att namnge element i en vektor. Koder nedan visar hur man ger namn till varje element i en vektor. Efter att ha namngett vektorn kan du nu plocka ut värde med hjälp av namn. # Sätter namn på respektive element i testScore names(testScore) &lt;- c(&quot;Zaida&quot;, &quot;Anna&quot;, &quot;Helena&quot;, &quot;Per&quot;, &quot;Filip&quot;, &quot;Annelie&quot;) testScore ## Zaida Anna Helena Per Filip Annelie ## 7.0 15.0 20.0 20.0 23.0 1.2 testScore[&quot;Per&quot;] ## Per ## 20 testScore[&quot;Filip&quot;] ## Filip ## 23 # Kolumnen i en data.frame oftast har namn. Objekt som har 2 eller mer dimensioner kan vi använda oss av dollar tecken. colnames(iris) ## [1] &quot;Sepal.Length&quot; &quot;Sepal.Width&quot; &quot;Petal.Length&quot; &quot;Petal.Width&quot; ## [5] &quot;Species&quot; "]
]
